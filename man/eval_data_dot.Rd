% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/eval_data_dot.R
\name{eval_data_dot}
\alias{eval_data_dot}
\title{Inject first argument in a call, usually data = (.)}
\usage{
eval_data_dot(
  call,
  arg = "data",
  value = as.symbol("."),
  env = caller_env(2L),
  abort_msg = gettextf(x = "Wrong '\%s' argument.", arg),
  abort_msg2 = gettext(i = "Implicit data-dot (.) not permitted"),
  abort_frame = caller_env()
)
}
\arguments{
\item{call}{A call object, usually a function call.}

\item{arg}{The name of the argument to inject, usually 'data' or '.data'.}

\item{value}{The value to inject, usually the symbol '.'.}

\item{env}{The environment where the evaluation of the data-dot-injected call
should be evaluated (by default, \code{caller_env(2L)}, should rarely be
changed).}

\item{abort_msg}{The message to use in case the 'data' argument is wrong.}

\item{abort_msg2}{An additional message to append to the error message in
case data-dot-injection is not permitted (when
\code{.SciViews.implicit.data.dot != TRUE})}

\item{abort_frame}{The environment to use for the error message, by default,
the caller environment (should rarely be changed).}
}
\value{
The result from evaluating the data-dot-injected call.
}
\description{
In case the \code{data = (.)} is missing in a call to a "data-dot"
function (a function that defines that its first argument \verb{data=} could be
missing, and it this case, it is considered to be \code{.}), this function does
the injection of the first argument in the call and evaluate it.
}
\details{
The call is \strong{not} checked if it is a correct function call. When called
from within a function, passing \code{\link[=sys.call]{sys.call()}} as \code{call}, it should be always
correct.
}
\examples{
# Here is how you create a data-dot function
my_subset <- function(data = (.), i, j) {
  if (!is.data.frame(data))
    return(eval_data_dot(sys.call()))

  # Code of the function
  # Second argument (i here) must not be a data.frame to avoid confusion
  data[i, j]
}
dtf1 <- data.frame(x = 1:3, y = 4:6)
my_subset(dtf1, 1, 'y')
# If data is in '.', it can be omitted
.= dtf1
my_subset(1, 'y')

# This mechanism is potentially confusing. You can inactivate it anywhere:
.SciViews.implicit.data.dot <- FALSE
# This time next call is wrong
#my_subset(1, 'y')
rm(.SciViews.implicit.data.dot) # Reactivate it
my_subset(1, 'y')
# Note that, if you have not defined '.' and try to use it, you got
# an error: uncomment next line to see it
#get_temp(".")
}
