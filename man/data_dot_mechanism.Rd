% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/prepare_data_dot.R
\name{data_dot_mechanism}
\alias{data_dot_mechanism}
\title{The data-dot mechanism}
\description{
The \strong{data-dot} mechanism injects automatically \code{.data = .} in
the call to a function when it detects it is necessary (most of the time,
when \verb{.data=} is missing, or a unnamed first argument is not suitable as
\code{.data}, i.e., it is not a \strong{data.frame}).
This is useful to avoid having to avoid writing \code{.} "everywhere" in your
functions when you use the explicit pipe operator \verb{\%>.\%}, or with \code{.= ...}
constructs.
The data-dot mechanism may fail with an error message if it cannot inject
\code{.} as \verb{.data=}, or when \code{.} is not found. It may also be prohibited if the
variable \code{.SciViews.implicit.data.dot} is set to
,0 \code{FALSE} (see examples).
}
\examples{
# Here is how you create a data-dot function
my_subset <- function(.data = (.), i, j) {
  # This makes it a data-dot function
  if (!prepare_data_dot(.data))
    return(recall_with_data_dot())

  # Code of the function
  # Second argument (i here) must not be a data.frame to avoid confusion
  message(".env has ", paste(names(.env), collapse = ", "))
  .data[i, j]
}
dtf1 <- data.frame(x = 1:3, y = 4:6)
my_subset(dtf1, 1, 'y')
# If .data is in '.', it can be omitted
.= dtf1
my_subset(1, 'y')

# This mechanism is potentially confusing. You can inactivate it anywhere:
.SciViews.implicit.data.dot <- FALSE
# This time next call is wrong
try(my_subset(1, 'y'))
# You must indicate '.' explicitly in that case:
my_subset(., 1, 'y')
rm(.SciViews.implicit.data.dot) # Reactivate it
my_subset(1, 'y') # Implicit again
# Note that, if you have not defined '.' and try to use it, you got
# an error:
rm(.)
try(my_subset(1, 'y'))
}
\seealso{
\code{\link[=prepare_data_dot]{prepare_data_dot()}}
}
